'use strict';

exports.__esModule = true;
exports.default = createUDPRelay;

var _dgram = require('dgram');

var _dgram2 = _interopRequireDefault(_dgram);

var _lruCache = require('lru-cache');

var _lruCache2 = _interopRequireDefault(_lruCache);

var _ip = require('ip');

var _ip2 = _interopRequireDefault(_ip);

var _utils = require('./utils');

var _encryptor = require('./encryptor');

var encryptor = _interopRequireWildcard(_encryptor);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// SOCKS5 UDP Request
// +----+------+------+----------+----------+----------+
// |RSV | FRAG | ATYP | DST.ADDR | DST.PORT |   DATA   |
// +----+------+------+----------+----------+----------+
// | 2  |  1   |  1   | Variable |    2     | Variable |
// +----+------+------+----------+----------+----------+
//
// SOCKS5 UDP Response
// +----+------+------+----------+----------+----------+
// |RSV | FRAG | ATYP | DST.ADDR | DST.PORT |   DATA   |
// +----+------+------+----------+----------+----------+
// | 2  |  1   |  1   | Variable |    2     | Variable |
// +----+------+------+----------+----------+----------+
//
// UDP Request (before encrypted)
// +------+----------+----------+----------+
// | ATYP | DST.ADDR | DST.PORT |   DATA   |
// +------+----------+----------+----------+
// |  1   | Variable |    2     | Variable |
// +------+----------+----------+----------+
//
// UDP Response (before encrypted)
// +------+----------+----------+----------+
// | ATYP | DST.ADDR | DST.PORT |   DATA   |
// +------+----------+----------+----------+
// |  1   | Variable |    2     | Variable |
// +------+----------+----------+----------+
//
// UDP Request and Response (after encrypted)
// +-------+--------------+
// |   IV  |    PAYLOAD   |
// +-------+--------------+
// | Fixed |   Variable   |
// +-------+--------------+

var NAME = 'udp_relay';
var LRU_OPTIONS = {
  max: 1000,
  maxAge: 10 * 1000,
  dispose: function dispose(key, socket) {
    // close socket if it's not closed
    if (socket) {
      socket.close();
    }
  }
};
var SOCKET_TYPE = ['udp4', 'udp6'];

function getIndex(_ref, _ref2) {
  var address = _ref.address,
      port = _ref.port;
  var dstAddrStr = _ref2.dstAddrStr,
      dstPortNum = _ref2.dstPortNum;

  return address + ':' + port + '_' + dstAddrStr + ':' + dstPortNum;
}

function createClient(logger, _ref3, onMsg, onClose) {
  var atyp = _ref3.atyp;

  var udpType = atyp === 1 ? 'udp4' : 'udp6';
  var socket = _dgram2.default.createSocket(udpType);

  socket.on('message', onMsg);

  socket.on('error', function (e) {
    logger.warn(NAME + ' client socket gets error: ' + e.message);
  });

  socket.on('close', onClose);

  return socket;
}

function createUDPRelaySocket(udpType, config, isServer, logger) {
  var localPort = config.localPort,
      serverPort = config.serverPort,
      password = config.password,
      method = config.method;

  var serverAddr = udpType === 'udp4' ? config.serverAddr : config.serverAddrIPv6;

  var encrypt = encryptor.encrypt.bind(null, password, method);
  var decrypt = encryptor.decrypt.bind(null, password, method);
  var socket = _dgram2.default.createSocket(udpType);
  var cache = new _lruCache2.default(Object.assign({}, LRU_OPTIONS, {
    maxAge: config.timeout * 1000
  }));
  var listenPort = isServer ? serverPort : localPort;

  socket.on('message', function (_msg, rinfo) {
    var msg = isServer ? decrypt(_msg) : _msg;
    var frag = msg[2];

    if (frag !== 0) {
      // drop those datagram that using frag
      return;
    }

    var dstInfo = (0, _utils.getDstInfoFromUDPMsg)(msg, isServer);
    var dstAddrStr = _ip2.default.toString(dstInfo.dstAddr);
    var dstPortNum = dstInfo.dstPort.readUInt16BE();
    var index = getIndex(rinfo, { dstAddrStr: dstAddrStr, dstPortNum: dstPortNum });

    logger.debug(NAME + ' receive message: ' + msg.toString('hex'));

    var client = cache.get(index);

    if (!client) {
      client = createClient(logger, dstInfo, function (msgStream) {
        // socket on message
        var incomeMsg = isServer ? encrypt(msgStream) : decrypt(msgStream);
        (0, _utils.sendDgram)(socket, incomeMsg, rinfo.port, rinfo.address);
      }, function () {
        // socket on close
        cache.del(index);
      });
      cache.set(index, client);
    }

    if (isServer) {
      (0, _utils.sendDgram)(client, msg.slice(dstInfo.totalLength), dstPortNum, dstAddrStr);
    } else {
      (0, _utils.sendDgram)(client,
      // skip RSV and FLAG
      encrypt(msg.slice(3)), serverPort, serverAddr);
    }
  });

  socket.on('error', function (err) {
    logger.error(NAME + ' socket err: ' + err.message);
    socket.close();
  });

  socket.on('close', function () {
    cache.reset();
  });

  socket.bind(listenPort, function () {
    logger.verbose(NAME + ' is listening on: ' + listenPort);
  });

  return socket;
}

function close(sockets) {
  sockets.forEach(function (socket) {
    (0, _utils.closeSilently)(socket);
  });
}

function createUDPRelay(config, isServer, logger) {
  var sockets = SOCKET_TYPE.map(function (udpType) {
    return createUDPRelaySocket(udpType, config, isServer, logger);
  });

  return {
    sockets: sockets,
    close: close.bind(null, sockets)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jcmVhdGVVRFBSZWxheS5qcyJdLCJuYW1lcyI6WyJjcmVhdGVVRFBSZWxheSIsImVuY3J5cHRvciIsIk5BTUUiLCJMUlVfT1BUSU9OUyIsIm1heCIsIm1heEFnZSIsImRpc3Bvc2UiLCJrZXkiLCJzb2NrZXQiLCJjbG9zZSIsIlNPQ0tFVF9UWVBFIiwiZ2V0SW5kZXgiLCJhZGRyZXNzIiwicG9ydCIsImRzdEFkZHJTdHIiLCJkc3RQb3J0TnVtIiwiY3JlYXRlQ2xpZW50IiwibG9nZ2VyIiwib25Nc2ciLCJvbkNsb3NlIiwiYXR5cCIsInVkcFR5cGUiLCJjcmVhdGVTb2NrZXQiLCJvbiIsImUiLCJ3YXJuIiwibWVzc2FnZSIsImNyZWF0ZVVEUFJlbGF5U29ja2V0IiwiY29uZmlnIiwiaXNTZXJ2ZXIiLCJsb2NhbFBvcnQiLCJzZXJ2ZXJQb3J0IiwicGFzc3dvcmQiLCJtZXRob2QiLCJzZXJ2ZXJBZGRyIiwic2VydmVyQWRkcklQdjYiLCJlbmNyeXB0IiwiYmluZCIsImRlY3J5cHQiLCJjYWNoZSIsIk9iamVjdCIsImFzc2lnbiIsInRpbWVvdXQiLCJsaXN0ZW5Qb3J0IiwiX21zZyIsInJpbmZvIiwibXNnIiwiZnJhZyIsImRzdEluZm8iLCJ0b1N0cmluZyIsImRzdEFkZHIiLCJkc3RQb3J0IiwicmVhZFVJbnQxNkJFIiwiaW5kZXgiLCJkZWJ1ZyIsImNsaWVudCIsImdldCIsIm1zZ1N0cmVhbSIsImluY29tZU1zZyIsImRlbCIsInNldCIsInNsaWNlIiwidG90YWxMZW5ndGgiLCJlcnIiLCJlcnJvciIsInJlc2V0IiwidmVyYm9zZSIsInNvY2tldHMiLCJmb3JFYWNoIiwibWFwIl0sIm1hcHBpbmdzIjoiOzs7a0JBMkp3QkEsYzs7QUEzSnhCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztJQUFZQyxTOzs7Ozs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QVIsQ0FIRixFQUlFOUIsVUFKRixFQUljRyxVQUpkO0FBTUQ7QUFDRixHQTNDRDs7QUE2Q0ExQixTQUFPZSxFQUFQLENBQVUsT0FBVixFQUFtQixVQUFDd0MsR0FBRCxFQUFTO0FBQzFCOUMsV0FBTytDLEtBQVAsQ0FBZ0I5RCxJQUFoQixxQkFBb0M2RCxJQUFJckMsT0FBeEM7QUFDQWxCLFdBQU9DLEtBQVA7QUFDRCxHQUhEOztBQUtBRCxTQUFPZSxFQUFQLENBQVUsT0FBVixFQUFtQixZQUFNO0FBQ3ZCZ0IsVUFBTTBCLEtBQU47QUFDRCxHQUZEOztBQUlBekQsU0FBTzZCLElBQVAsQ0FBWU0sVUFBWixFQUF3QixZQUFNO0FBQzVCMUIsV0FBT2lELE9BQVAsQ0FBa0JoRSxJQUFsQiwwQkFBMkN5QyxVQUEzQztBQUNELEdBRkQ7O0FBSUEsU0FBT25DLE1BQVA7QUFDRDs7QUFFRCxTQUFTQyxLQUFULENBQWUwRCxPQUFmLEVBQXdCO0FBQ3RCQSxVQUFRQyxPQUFSLENBQWdCLFVBQUM1RCxNQUFELEVBQVk7QUFDMUIsOEJBQWNBLE1BQWQ7QUFDRCxHQUZEO0FBR0Q7O0FBRWMsU0FBU1IsY0FBVCxDQUF3QjRCLE1BQXhCLEVBQWdDQyxRQUFoQyxFQUEwQ1osTUFBMUMsRUFBa0Q7QUFDL0QsTUFBTWtELFVBQVV6RCxZQUFZMkQsR0FBWixDQUFnQjtBQUFBLFdBQzlCMUMscUJBQXFCTixPQUFyQixFQUE4Qk8sTUFBOUIsRUFBc0NDLFFBQXRDLEVBQWdEWixNQUFoRCxDQUQ4QjtBQUFBLEdBQWhCLENBQWhCOztBQUdBLFNBQU87QUFDTGtELG9CQURLO0FBRUwxRCxXQUFPQSxNQUFNNEIsSUFBTixDQUFXLElBQVgsRUFBaUI4QixPQUFqQjtBQUZGLEdBQVA7QUFJRCIsImZpbGUiOiJjcmVhdGVVRFBSZWxheS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZ3JhbSBmcm9tICdkZ3JhbSc7XG5pbXBvcnQgTFJVIGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQgaXAgZnJvbSAnaXAnO1xuaW1wb3J0IHsgZ2V0RHN0SW5mb0Zyb21VRFBNc2csIHNlbmREZ3JhbSwgY2xvc2VTaWxlbnRseSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0ICogYXMgZW5jcnlwdG9yIGZyb20gJy4vZW5jcnlwdG9yJztcblxuLy8gU09DS1M1IFVEUCBSZXF1ZXN0XG4vLyArLS0tLSstLS0tLS0rLS0tLS0tKy0tLS0tLS0tLS0rLS0tLS0tLS0tLSstLS0tLS0tLS0tK1xuLy8gfFJTViB8IEZSQUcgfCBBVFlQIHwgRFNULkFERFIgfCBEU1QuUE9SVCB8ICAgREFUQSAgIHxcbi8vICstLS0tKy0tLS0tLSstLS0tLS0rLS0tLS0tLS0tLSstLS0tLS0tLS0tKy0tLS0tLS0tLS0rXG4vLyB8IDIgIHwgIDEgICB8ICAxICAgfCBWYXJpYWJsZSB8ICAgIDIgICAgIHwgVmFyaWFibGUgfFxuLy8gKy0tLS0rLS0tLS0tKy0tLS0tLSstLS0tLS0tLS0tKy0tLS0tLS0tLS0rLS0tLS0tLS0tLStcbi8vXG4vLyBTT0NLUzUgVURQIFJlc3BvbnNlXG4vLyArLS0tLSstLS0tLS0rLS0tLS0tKy0tLS0tLS0tLS0rLS0tLS0tLS0tLSstLS0tLS0tLS0tK1xuLy8gfFJTViB8IEZSQUcgfCBBVFlQIHwgRFNULkFERFIgfCBEU1QuUE9SVCB8ICAgREFUQSAgIHxcbi8vICstLS0tKy0tLS0tLSstLS0tLS0rLS0tLS0tLS0tLSstLS0tLS0tLS0tKy0tLS0tLS0tLS0rXG4vLyB8IDIgIHwgIDEgICB8ICAxICAgfCBWYXJpYWJsZSB8ICAgIDIgICAgIHwgVmFyaWFibGUgfFxuLy8gKy0tLS0rLS0tLS0tKy0tLS0tLSstLS0tLS0tLS0tKy0tLS0tLS0tLS0rLS0tLS0tLS0tLStcbi8vXG4vLyBVRFAgUmVxdWVzdCAoYmVmb3JlIGVuY3J5cHRlZClcbi8vICstLS0tLS0rLS0tLS0tLS0tLSstLS0tLS0tLS0tKy0tLS0tLS0tLS0rXG4vLyB8IEFUWVAgfCBEU1QuQUREUiB8IERTVC5QT1JUIHwgICBEQVRBICAgfFxuLy8gKy0tLS0tLSstLS0tLS0tLS0tKy0tLS0tLS0tLS0rLS0tLS0tLS0tLStcbi8vIHwgIDEgICB8IFZhcmlhYmxlIHwgICAgMiAgICAgfCBWYXJpYWJsZSB8XG4vLyArLS0tLS0tKy0tLS0tLS0tLS0rLS0tLS0tLS0tLSstLS0tLS0tLS0tK1xuLy9cbi8vIFVEUCBSZXNwb25zZSAoYmVmb3JlIGVuY3J5cHRlZClcbi8vICstLS0tLS0rLS0tLS0tLS0tLSstLS0tLS0tLS0tKy0tLS0tLS0tLS0rXG4vLyB8IEFUWVAgfCBEU1QuQUREUiB8IERTVC5QT1JUIHwgICBEQVRBICAgfFxuLy8gKy0tLS0tLSstLS0tLS0tLS0tKy0tLS0tLS0tLS0rLS0tLS0tLS0tLStcbi8vIHwgIDEgICB8IFZhcmlhYmxlIHwgICAgMiAgICAgfCBWYXJpYWJsZSB8XG4vLyArLS0tLS0tKy0tLS0tLS0tLS0rLS0tLS0tLS0tLSstLS0tLS0tLS0tK1xuLy9cbi8vIFVEUCBSZXF1ZXN0IGFuZCBSZXNwb25zZSAoYWZ0ZXIgZW5jcnlwdGVkKVxuLy8gKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG4vLyB8ICAgSVYgIHwgICAgUEFZTE9BRCAgIHxcbi8vICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuLy8gfCBGaXhlZCB8ICAgVmFyaWFibGUgICB8XG4vLyArLS0tLS0tLSstLS0tLS0tLS0tLS0tLStcblxuY29uc3QgTkFNRSA9ICd1ZHBfcmVsYXknO1xuY29uc3QgTFJVX09QVElPTlMgPSB7XG4gIG1heDogMTAwMCxcbiAgbWF4QWdlOiAxMCAqIDEwMDAsXG4gIGRpc3Bvc2U6IChrZXksIHNvY2tldCkgPT4ge1xuICAgIC8vIGNsb3NlIHNvY2tldCBpZiBpdCdzIG5vdCBjbG9zZWRcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICB9XG4gIH0sXG59O1xuY29uc3QgU09DS0VUX1RZUEUgPSBbJ3VkcDQnLCAndWRwNiddO1xuXG5mdW5jdGlvbiBnZXRJbmRleCh7IGFkZHJlc3MsIHBvcnQgfSwgeyBkc3RBZGRyU3RyLCBkc3RQb3J0TnVtIH0pIHtcbiAgcmV0dXJuIGAke2FkZHJlc3N9OiR7cG9ydH1fJHtkc3RBZGRyU3RyfToke2RzdFBvcnROdW19YDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KGxvZ2dlciwgeyBhdHlwIC8qICwgZHN0QWRkciwgZHN0UG9ydCAqLyB9LCBvbk1zZywgb25DbG9zZSkge1xuICBjb25zdCB1ZHBUeXBlID0gKGF0eXAgPT09IDEgPyAndWRwNCcgOiAndWRwNicpO1xuICBjb25zdCBzb2NrZXQgPSBkZ3JhbS5jcmVhdGVTb2NrZXQodWRwVHlwZSk7XG5cbiAgc29ja2V0Lm9uKCdtZXNzYWdlJywgb25Nc2cpO1xuXG4gIHNvY2tldC5vbignZXJyb3InLCAoZSkgPT4ge1xuICAgIGxvZ2dlci53YXJuKGAke05BTUV9IGNsaWVudCBzb2NrZXQgZ2V0cyBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH0pO1xuXG4gIHNvY2tldC5vbignY2xvc2UnLCBvbkNsb3NlKTtcblxuICByZXR1cm4gc29ja2V0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVRFBSZWxheVNvY2tldCh1ZHBUeXBlLCBjb25maWcsIGlzU2VydmVyLCBsb2dnZXIpIHtcbiAgY29uc3Qge1xuICAgIGxvY2FsUG9ydCwgc2VydmVyUG9ydCxcbiAgICBwYXNzd29yZCwgbWV0aG9kLFxuICB9ID0gY29uZmlnO1xuICBjb25zdCBzZXJ2ZXJBZGRyID0gdWRwVHlwZSA9PT0gJ3VkcDQnID8gY29uZmlnLnNlcnZlckFkZHIgOiBjb25maWcuc2VydmVyQWRkcklQdjY7XG5cbiAgY29uc3QgZW5jcnlwdCA9IGVuY3J5cHRvci5lbmNyeXB0LmJpbmQobnVsbCwgcGFzc3dvcmQsIG1ldGhvZCk7XG4gIGNvbnN0IGRlY3J5cHQgPSBlbmNyeXB0b3IuZGVjcnlwdC5iaW5kKG51bGwsIHBhc3N3b3JkLCBtZXRob2QpO1xuICBjb25zdCBzb2NrZXQgPSBkZ3JhbS5jcmVhdGVTb2NrZXQodWRwVHlwZSk7XG4gIGNvbnN0IGNhY2hlID0gbmV3IExSVShPYmplY3QuYXNzaWduKHt9LCBMUlVfT1BUSU9OUywge1xuICAgIG1heEFnZTogY29uZmlnLnRpbWVvdXQgKiAxMDAwLFxuICB9KSk7XG4gIGNvbnN0IGxpc3RlblBvcnQgPSAoaXNTZXJ2ZXIgPyBzZXJ2ZXJQb3J0IDogbG9jYWxQb3J0KTtcblxuICBzb2NrZXQub24oJ21lc3NhZ2UnLCAoX21zZywgcmluZm8pID0+IHtcbiAgICBjb25zdCBtc2cgPSBpc1NlcnZlciA/IGRlY3J5cHQoX21zZykgOiBfbXNnO1xuICAgIGNvbnN0IGZyYWcgPSBtc2dbMl07XG5cbiAgICBpZiAoZnJhZyAhPT0gMCkge1xuICAgICAgLy8gZHJvcCB0aG9zZSBkYXRhZ3JhbSB0aGF0IHVzaW5nIGZyYWdcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkc3RJbmZvID0gZ2V0RHN0SW5mb0Zyb21VRFBNc2cobXNnLCBpc1NlcnZlcik7XG4gICAgY29uc3QgZHN0QWRkclN0ciA9IGlwLnRvU3RyaW5nKGRzdEluZm8uZHN0QWRkcik7XG4gICAgY29uc3QgZHN0UG9ydE51bSA9IGRzdEluZm8uZHN0UG9ydC5yZWFkVUludDE2QkUoKTtcbiAgICBjb25zdCBpbmRleCA9IGdldEluZGV4KHJpbmZvLCB7IGRzdEFkZHJTdHIsIGRzdFBvcnROdW0gfSk7XG5cbiAgICBsb2dnZXIuZGVidWcoYCR7TkFNRX0gcmVjZWl2ZSBtZXNzYWdlOiAke21zZy50b1N0cmluZygnaGV4Jyl9YCk7XG5cbiAgICBsZXQgY2xpZW50ID0gY2FjaGUuZ2V0KGluZGV4KTtcblxuICAgIGlmICghY2xpZW50KSB7XG4gICAgICBjbGllbnQgPSBjcmVhdGVDbGllbnQobG9nZ2VyLCBkc3RJbmZvLCAobXNnU3RyZWFtKSA9PiB7XG4gICAgICAgIC8vIHNvY2tldCBvbiBtZXNzYWdlXG4gICAgICAgIGNvbnN0IGluY29tZU1zZyA9IChpc1NlcnZlciA/IGVuY3J5cHQobXNnU3RyZWFtKSA6IGRlY3J5cHQobXNnU3RyZWFtKSk7XG4gICAgICAgIHNlbmREZ3JhbShzb2NrZXQsIGluY29tZU1zZywgcmluZm8ucG9ydCwgcmluZm8uYWRkcmVzcyk7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIC8vIHNvY2tldCBvbiBjbG9zZVxuICAgICAgICBjYWNoZS5kZWwoaW5kZXgpO1xuICAgICAgfSk7XG4gICAgICBjYWNoZS5zZXQoaW5kZXgsIGNsaWVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzU2VydmVyKSB7XG4gICAgICBzZW5kRGdyYW0oXG4gICAgICAgIGNsaWVudCwgbXNnLnNsaWNlKGRzdEluZm8udG90YWxMZW5ndGgpLFxuICAgICAgICBkc3RQb3J0TnVtLCBkc3RBZGRyU3RyXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kRGdyYW0oXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgLy8gc2tpcCBSU1YgYW5kIEZMQUdcbiAgICAgICAgZW5jcnlwdChtc2cuc2xpY2UoMykpLFxuICAgICAgICBzZXJ2ZXJQb3J0LCBzZXJ2ZXJBZGRyXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgc29ja2V0Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBsb2dnZXIuZXJyb3IoYCR7TkFNRX0gc29ja2V0IGVycjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICBzb2NrZXQuY2xvc2UoKTtcbiAgfSk7XG5cbiAgc29ja2V0Lm9uKCdjbG9zZScsICgpID0+IHtcbiAgICBjYWNoZS5yZXNldCgpO1xuICB9KTtcblxuICBzb2NrZXQuYmluZChsaXN0ZW5Qb3J0LCAoKSA9PiB7XG4gICAgbG9nZ2VyLnZlcmJvc2UoYCR7TkFNRX0gaXMgbGlzdGVuaW5nIG9uOiAke2xpc3RlblBvcnR9YCk7XG4gIH0pO1xuXG4gIHJldHVybiBzb2NrZXQ7XG59XG5cbmZ1bmN0aW9uIGNsb3NlKHNvY2tldHMpIHtcbiAgc29ja2V0cy5mb3JFYWNoKChzb2NrZXQpID0+IHtcbiAgICBjbG9zZVNpbGVudGx5KHNvY2tldCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVVRFBSZWxheShjb25maWcsIGlzU2VydmVyLCBsb2dnZXIpIHtcbiAgY29uc3Qgc29ja2V0cyA9IFNPQ0tFVF9UWVBFLm1hcCh1ZHBUeXBlID0+XG4gICAgY3JlYXRlVURQUmVsYXlTb2NrZXQodWRwVHlwZSwgY29uZmlnLCBpc1NlcnZlciwgbG9nZ2VyKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzb2NrZXRzLFxuICAgIGNsb3NlOiBjbG9zZS5iaW5kKG51bGwsIHNvY2tldHMpLFxuICB9O1xufVxuIl19